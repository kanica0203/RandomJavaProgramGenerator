ClassStart := (ClassDeclaration | InterfaceDeclaration)
ClassDeclaration := PackageName ClassModifier class Identifier ClassBody
PackageName := package NameOfPackage
ClassModifier := (public)
ClassBody := {ClassBodDeclaration}
ClassBodDeclaration := {FieldDeclarator} {ConstructorDeclaration} {MethodDeclaration | RMethodDeclaration}
FieldDeclarator := (Type Identifier ;)
Type := (BasicType)
BasicType := (int | double | char | boolean | String)
ConstructorDeclaration := ConstructorModifier Identifier [CParameterList] ConstructorBody
ConstructorModifier := (public | private | protected)
CParameterList := CParameter {, CParameter}
CParameter := (Type Identifier)
ConstructorBody := {CLocalVariableDeclaration} {Statement}
CLocalVariableDeclaration := {Type Identifier = Literal ;}
MethodDeclaration := MethodModifier (MReturnType) Identifier [MParameterList] MethodBody
MethodModifier := (public | private | protected)
MReturnType := (int | char | double | boolean)
MParameterList := MParameter {, MParameter}
MParameter := (Type Identifier)
MethodBody := {MLocalVariableDeclaration} {Statement} (return ReturnIdentifier ;)
MLocalVariableDeclaration := {Type Identifier = Literal ;}
Literal := (IntegerLiteral | FloatLiteral | CharacterLiteral | BoolLiteral | StringLiteral)
IntegerLiteral := SInteger {Integer}
SInteger := (1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9)
Integer := (0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9)
FloatLiteral := SInteger {Integer} . Integer {Integer}
CharacterLiteral := (' alphabet ')
alphabet := (smallAlphabet | bigAlphabet)
smallAlphabet := (a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z)
bigAlphabet := (A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z)
StringLiteral := " {alphabet} {alphabet} "
Statement := (Assignment | IfThenStatement |  WhileStatement | ForStatement | DoStatement)
Assignment := (Identifier = Expression) ;
Expression := (NumericExpression | Identifier | Literal | LogicalExpression | StringExpression)
NumericExpression := (ArithmeticExpression | PostIncrementDecrement | PostIncrementDecrement)
PreIncrementDecrement := (PrePostOperators Identifier)
PostIncrementDecrement := (Identifier PrePostOperators)
PrePostOperators := (++ | --)
ArithmeticExpression := (Expression ArithmeticOperator Expression)
ArithmeticOperator := (+ | * | / | -)
IfThenStatement := if (RelationalExpression) EndCond Block {Elseif} [ElsePart]
ForStatement := for [Assignment] ; RelationalExpression ; Assignment EndCond (Statement | Block)
ElsePart := else Block
RelationalExpression := (Identifier RelationalOperation ConditionalStat)
ConditionalStat := (IntegerLiteral | FloatLiteral | CharacterLiteral | BoolLiteral | StringLiteral)
BoolLiteral := (true | false)
RelationalOperation := (== | != | > | >= | < | <=)
Block := {Statement}
StringExpression := (Identifier StringOperator Identifier)
StringOperator := (+)
LogicalExpression := (Identifier LogicalOperator Identifier)
LogicalOperator := (& | ^ | &&)
Elseif := else if (RelationalExpression) EndCond Block
WhileStatement := while (RelationalExpression) EndCond Block
DoStatement := do Block while (RelationalExpression) EndCond ;
RMethodDeclaration := MethodModifier (MReturnType) Identifier RecursiveMBody
RecursiveMBody := {MLocalVariableDeclaration} {Statement} (RecursiveCall) (RecursiveTermination) (return ReturnIdentifier ;)
RecursiveTermination := if (RelationalExpression) EndCond (return ReturnIdentifier ;)
RecursiveCall := CallMethodAgain ;
InterfaceDeclaration := PackageName ClassModifier interface Identifier InterfaceBody
InterfaceBody := {MethodDefinition}
MethodDefinition := IModifier void Identifier [IParameterList] EndCond ;
IModifier := (public | abstract)
IParameterList := IParameter {, IParameter}
IParameter := (Type Identifier)