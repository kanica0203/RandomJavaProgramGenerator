package Generator;

import Parser.Node;
import config.Generator_Specs;

import java.util.*;

/*
 * Generate the classes
 */
public class Structure_Final {
    // Local copy of the rules and specs
    LinkedHashMap<String, List<Node>> my_rules =  new LinkedHashMap<>();
    Generator_Specs my_specs;

    // My rules passed on to the object
    public ScopeTable scope_table = new ScopeTable();
    // Local variable for indentation purposes
    int indentation = 0;
    // Random value generator
    Random rand = new Random();
    // random isn't truly random for smaller values.!!
    int prev_random = 0;
    String NameOfPackage = "GeneratedClasses";

    public Structure_Final(){

    }
    /*
     *  Constructor that takes in the rules to initialize
     *  the local variable.
     *
     *  Param :-
     *      my_rules        - List of rules generated by parsing the grammar
     */
    public Structure_Final(LinkedHashMap<String, List<Node>> my_rules, Generator_Specs my_specs) {
        this.my_rules = my_rules;
        this.my_specs = my_specs;
        this.scope_table.current_expression.setMax_statement(my_specs.getMax_stmts_methods());
//        this.rand.
    }

    /*
     *  Indent the code of the generated program
     *
     *  Param :-
     *      indentation     -   Level of indentation
     *      generated_code  -   code being generated
     *
     *  Return :-
     *      StringBuilder   -   return updated code
     */
    private StringBuilder indent_generated_code(int indentation, StringBuilder generated_code) {
        for ( int add_space = 0; add_space < indentation ; add_space++) {
            generated_code.append("\t");
        }
        return generated_code;
    }

    /*
     *
     *  Get the type of literal to find depending on the expression type
     *
     *  Param :-
     *      type            -   Variable type to search literal for
     *
     *  Return :-
     *      String          -   Literal that matches with the type
     */
    public String get_literal(String type) {
        String search_for = "";
        switch (type) {
            case "int":
                search_for = "IntegerLiteral";
                break;
            case "double":
                search_for = "FloatLiteral";
                break;
            case "char":
                search_for = "CharacterLiteral";
                break;
            case "boolean":
                search_for = "BoolLiteral";
                break;
            case "String":
                search_for = "StringLiteral";
                break;
        }
        return search_for;
    }

    public int get_new_random(int limit) {
        int random_number = rand.nextInt(limit);
        //System.out.println(" The new limit is " + limit + " random "+random_number + " preb " + prev_random);
        if( limit != 0 ) {
            while ( random_number == prev_random) {
                random_number = rand.nextInt(limit);
            }
        }
        prev_random = random_number;
        return random_number;
    }

    /*
     *
     *  Logic with the creation and management of identifiers used in the generated program
     *
     *  Param :-
     *      start_with      -   To figure out how we ended up here
     *      generated_code  -   Code to continue modifying on
     *      child_node      -   The current node details
     *
     *  Return :-
     *      String          -   The identifier name created or to be used.
     */
    private String identifier_rules(String start_with, StringBuilder generated_code, Node child_node) {
        //need to add stuff to choose identifier from scope depending on existing type;
        //System.out.println(" \nStarted with for identifier.." + start_with + " - " + child_node.getName());
        MyIdentifier identifier =  new MyIdentifier();
        identifier.generateIdentifier();

        // Creating a identifier requires update to the scope_table
        if ( start_with.contains("ClassDeclaration") ) {
            // Add the generated class name to scope table class name
            scope_table.class_name = identifier.getIdentifier_name();
        } else if ( start_with.contains("InterfaceDeclaration") ) {
            // Add the generated class name to scope table class name
            scope_table.class_name = identifier.getIdentifier_name();
        } else if ( start_with.contains("FieldDeclarator")) {
            // Identifiers for field declaration ( class members )
            // Add the generated variable to the scope table.
            scope_table.class_variable_list.put(identifier.getIdentifier_name(),scope_table.prev_type);
            scope_table.prev_type = "";
        } else if ( start_with.contains("ConstructorDeclaration")) {
            // Identifiers for the Constructor Declaration
            // It is the same as our class Name
            identifier.setIdentifier_name(scope_table.class_name);
            // Construct the constructor list for the class
            scope_table.constructor_list.setConstructor_name(scope_table.class_name);
            scope_table.constructor_list.add_new_signature();
            scope_table.statement_in_constuctor = true;
        } else if ( start_with.contains("MethodDeclaration")) {
            // New method being created, add it to the method class
            scope_table.method_list.add_new_method(identifier.getIdentifier_name());
            scope_table.statement_in_constuctor = false;
        } else if ( start_with.contains("MethodDefinition")) {
            // New method being created, add it to the method class
            scope_table.interface_list.add_new_interface(identifier.getIdentifier_name());
        } else if ( start_with.contains("CParameter") ) {
            // A new constructor parameter is created
            scope_table.constructor_list.add_current_parameter(identifier.getIdentifier_name(),scope_table.prev_type);
            //could have added it later in code instead using 4 times below
            //but need to be cross verified in the future.
            scope_table.current_expression.setLhs_type(scope_table.prev_type);
            scope_table.prev_type = "";
        } else if (start_with.contains("CLocalVariableDeclaration")) {
            // A new variable in a constructor is created
            scope_table.constructor_list.add_current_local(identifier.getIdentifier_name(),scope_table.prev_type);
            scope_table.current_expression.setLhs_type(scope_table.prev_type);
            scope_table.prev_type = "";
        } else if ( start_with.contains("MParameter") ) {
            // A new constructor parameter is created
            scope_table.method_list.add_current_parameter(identifier.getIdentifier_name(),scope_table.prev_type);
            scope_table.current_expression.setLhs_type(scope_table.prev_type);
            scope_table.prev_type = "";
        } else if ( start_with.contains("MLocalVariableDeclaration")) {
            // A new variable in a method is created
            scope_table.method_list.add_current_local(identifier.getIdentifier_name(),scope_table.prev_type);
            scope_table.current_expression.setLhs_type(scope_table.prev_type);
            scope_table.prev_type = "";
        } else if ( start_with.contains("IParameter") ) {
            // A new constructor parameter is created
            scope_table.interface_list.add_current_parameter(identifier.getIdentifier_name(),scope_table.prev_type);
            scope_table.current_expression.setLhs_type(scope_table.prev_type);
            scope_table.prev_type = "";
        }else if (child_node.getName().contains("ReturnIdentifier")){
            // If there was no return variable , manually override to give an Literal.
            //System.out.println(" return indentifier "+ scope_table.method_list.getCurrent_returntype() );
            String my_return_variable = scope_table.get_identifier_by_type(scope_table.method_list.getCurrent_returntype());
            StringBuilder temp = new StringBuilder();
            if(my_return_variable == null) {
                my_return_variable = generate_program(get_literal(scope_table.method_list.getCurrent_returntype()),temp);
            }
            identifier.setIdentifier_name(my_return_variable);
        } else if ( scope_table.current_expression.isIs_expression() ||
                scope_table.current_expression.isIs_assignment()) {
            //System.out.println(" is it assignment?" + scope_table.current_expression.isIs_assignment() );
            //System.out.println(" is it expression?" + scope_table.current_expression.isIs_expression() );
            // if the identifier is between an expression or assignment.. needs to return by type.
            identifier.setIdentifier_name(scope_table.get_identifier_by_type(scope_table.current_expression.getLhs_type()));
        } else if ( start_with.contains("Assignment")) {
            // If a assignment statement requests an Identifier, it's for using it.
            // Don't create, get one from scope_table
            List<String> my_local_var= scope_table.get_identifier_in_scope();
            identifier.setIdentifier_name(my_local_var.get(0));
            scope_table.current_expression.setLhs_type(my_local_var.get(1));
            scope_table.current_expression.setIs_assignment(true);
        } else if ( start_with.contains("Expression")) {
            // If a Expression statement requests an Identifier, it's for using it.
            // Don't create, get one from scope_table
            List<String> my_local_var = scope_table.get_identifier_in_scope();
            identifier.setIdentifier_name(my_local_var.get(0));
            scope_table.current_expression.setLhs_type(my_local_var.get(1));
            scope_table.current_expression.setIs_expression(true);
        } else if ( (start_with.contains("PreIncrementDecrement") && !child_node.getName().contains("PrePostOperators")) ||
                (start_with.contains("PostIncrementDecrement") && child_node.getName().contains("PrePostOperators"))){
            // Remove trailing spaces
            generated_code.replace(0,generated_code.length(),generated_code.toString().trim());
            // //System.out.println("\n\n\n\n\n\n\n\n\\\n\n\n\n\n\n\n\n" + scope_table.current_expression.getLhs_type());
            identifier.setIdentifier_name(scope_table.get_identifier_by_type(scope_table.current_expression.getLhs_type()));
        }
        return identifier.getIdentifier_name();
    }

    /*
     *  Generate the program based on the production rules and recursively calls itself till
     *  the rules end in termination
     *
     *  Param :-
     *      start_with      -   production rule for LHS that is used to generate the statements
     *      generated_code  -   code being generated
     *
     *  Return :-
     *      String          -   code that has been generated
     */
    public String generate_program(String start_with, StringBuilder generated_code) {
        //System.out.println(" starting generation with " + start_with);
        // Whether to provide a chance to check for randomization or decision to occur
        boolean check_chance = true;
        // Occurrence of a variable , defaults to 1.
        int occur_left = 1;

        // Get the possible values of the node provided
        List<Node> nodes = my_rules.get(start_with);
        if (nodes != null) {
            // Figuring out how many times an element must or can occur based on the
            // input braces (), {} , []
            // 0 - no braces    , 1 - one occurance
            // 2 - zero or one  , 3 - zero or more

            // traverse to the nodes, all elements on the RHS of the production rule
            for (int out_i = 0; out_i < nodes.size(); out_i++) {
                // ** A group means in the same bracket         **
                // ** The sub split means they occur together   **

                Node child_node = nodes.get(out_i);
                // Find the groups and splits provided to decide on way to proceed
                int start_group = nodes.indexOf(child_node);
                int end_group = start_group;
                int max_split = 1;
                int prev_split = child_node.getSplit_group();
                for (int i = start_group; i < nodes.size(); i++) {
                    if (child_node.getGroup() == nodes.get(i).getGroup()) {
                        end_group = i;
                        if((child_node.getSplit_group() != nodes.get(i).getSplit_group()) &&
                                (prev_split != nodes.get(i).getSplit_group())) {
                            max_split++; // get distinct splits
                            prev_split = nodes.get(i).getSplit_group();
                        }
                    }
                }

                // Group starts from start_group to end_group
                //System.out.println(" start_group is  " + start_group + " and end_group is " + end_group + " chance " + check_chance);
                //System.out.println(" node : " + child_node.getName() + " po : " + child_node.getPossible_occurances() );

                //specifying small value to default
                int default_occurrence = 2;
                if(check_chance) {
                    default_occurrence = check_restrictions(child_node.getName());
                    //System.out.println(" default occurnce of " + child_node.getName() + " is " + default_occurrence);
                    // incase we exhausted the node continue.
                    if (default_occurrence == -1) {
                        //System.out.println(" decided to skip due to resetrictions for  " + child_node.getName());
                        occur_left = 1;
                        check_chance = true;
                        if (max_split > 1) {
                            //System.out.println(" has split.. going to next one");
                            for(int i= out_i +1; i<=end_group;i++) {
                                if(child_node.getSplit_group() != nodes.get(i).getSplit_group() ) {
                                    out_i = i-1;
                                    break;
                                }
                            }
                        } else {
                            //System.out.println(" bad luck no split..." + child_node.getName());
                            out_i = end_group;
                        }
                        continue;
                    }
                }

                // For zero or one occurrence if chance hasn't been taken
                if ( child_node.getPossible_occurances() == 2 && check_chance) {
                    // if zero , Skip the group.. Not chosen today
                    if ( rand.nextInt(2) == 0 ) {
//                        //System.out.println(" skipping " + child_node.getName());
                        out_i = end_group;

                        // Special case where a duplicate single parameter constructor has been generated again
                        if(child_node.getName().contains("CParameterList") && scope_table.constructor_list.is_duplication()) {
                              //System.out.println(" Found a constructor start empty duplication..!!");
                            check_chance = false;
                        } else {
                            // don't wanna run this round as it has been chosen not to run.
                            continue;
                        }
                    } else {
                        // We don't want to check possibility for sub group again, so reset it where group ends
                        check_chance = false;
                    }
                } else if (child_node.getPossible_occurances() == 3 && check_chance) {
                    // For one or more occurrences if chance hasn't been taken
                    occur_left = rand.nextInt(default_occurrence) + 1 ;
                    inc_restriction(child_node.getName(),occur_left);
                    check_chance = false;
//                    //System.out.println("choose to occur " + occur_left + " times.. ");
                }
                //System.out.println(child_node.getName() + " left : " + occur_left);

                // When there is more than one split, choose a random split from within the group
                // scenarios where we have | in the grammar
                if (max_split > 1) {
                    // we don't want recursive expressions being called.. , Set a limit of 5 for now.
                    if (scope_table.current_expression.get_express_nesting_level() > 20 &&
                            start_with.equalsIgnoreCase("Expression")) {
                        //System.out.println(" Expression nesting reached... , need to breakdown.." + scope_table.current_expression.get_express_nesting_level());
                        for (int i = start_group; i <= end_group; i++) {
                            if (nodes.get(i).getName().equalsIgnoreCase("Literal")) {
                                out_i = i;
                                break;
                            }
                        }
                    } else if(scope_table.current_expression.getStatement_nest_level() > my_specs.getMax_stmts_methods() &&
                            start_with.contains("Statement"))  {
                        // Don't want to be calling the statements recursively.. , Set a limit of 5 for now.
                        //System.out.println(" Statement nesting reached... , need to breakdown.." + scope_table.current_expression.getStatement_nest_level());
                        for (int i = start_group; i <= end_group; i++) {
                            //System.out.println(" nodes " + nodes.get(i).getName());
                            if (nodes.get(i).getName().contains("Assignment")) {
                                out_i = i;
                                break;
                            }
                        }
                    } else if(start_with.equalsIgnoreCase("Expression")) {
                        //verify if there expressions are supposed to be here...
                        //System.out.println(" inside expresssionn..");
                        //System.out.println(" i'm herer for something.... " + scope_table.current_expression.getLhs_type() + " -- ");
                        String search_for ="";

                        if (scope_table.current_expression.getLhs_type().contains("boolean")) {
                            // logical expression for boolean operations
                            search_for = "LogicalExpression";
                        } else if (scope_table.current_expression.getLhs_type().contains("String")) {
                            // String expression for String operations
                            search_for = "StringExpression";
                        }else if(rand.nextInt(200) < 100) {

                            if (rand.nextInt(100) > 50 &&
                                    scope_table.get_identifier_by_type(scope_table.current_expression.getLhs_type()) != null) {
                                search_for = "Identifier";
                            } else if (//scope_table.current_expression.get_express_nesting_level() < 3 &&
                                    scope_table.current_expression.getLhs_type().contains("int") ||
                                            scope_table.current_expression.getLhs_type().contains("double")) {
                                search_for = "NumericExpression";
                            }  else {
                                search_for = "Literal";
                            }

                        } else {
                            search_for = "Literal";//get_literal(scope_table.current_expression.getLhs_type());
                        }
                        //System.out.println(" searchng for " + search_for);
                        //if int need to get NumericExpression
                        for (int i = start_group; i <= end_group; i++) {
                            if (nodes.get(i).getName().contains(search_for)) {
                                out_i = i;
                                break;
                            }
                        }

                    } else if (start_with.contains("RelationalOperation")) {
                        String search_for = "";
                        if (scope_table.current_expression.getLhs_type().contains("boolean") ||
                                scope_table.current_expression.getLhs_type().contains("String")) {
                            if (rand.nextInt(100) < 50) {
                                search_for = "==";
                            } else {
                                search_for = "!=";
                            }
                            for (int i = start_group; i <= end_group; i++) {
                                if (nodes.get(i).getName().equalsIgnoreCase(search_for)) {
                                    out_i = i;
                                    break;
                                }
                            }
                        } else {
                            int my_split = get_new_random(max_split+1);
                            //System.out.println(" Choosing the random bool value : " + my_split + " out fo " + max_split);
                            int prev_start_group = start_group;
                            for (int i = start_group; i <= end_group && (my_split > 0); i++) {
                                if (prev_start_group != nodes.get(i).getSplit_group()) {
                                    prev_start_group = nodes.get(i).getSplit_group();
                                    //old reasoning
                                    //in case the random is in middle but we want the whole split
                                    //i to be the first occurance of sub split inside the group
                                    out_i = i;
                                    my_split--;
                                }
                            }
                        }
                    } else if (start_with.contains("ConditionalStat")) {
                        // for conditional statements we use statements based on the LHS for proper comparisons
                        String search_for = get_literal(scope_table.current_expression.getLhs_type());
                        if (scope_table.current_expression.isIs_expression()) {
                            for (int i = start_group; i <= end_group; i++) {
                                if (nodes.get(i).getName().equalsIgnoreCase(search_for)) {
                                    out_i = i;
                                    break;
                                }
                            }
                        }
                    } else {
                        // choose a random split from the middle
                        int my_split = get_new_random(max_split+1);
                        //System.out.println(" Choosing the random value : " + my_split + " out fo " + max_split);
                        int prev_start_group = start_group;
                        for (int i = start_group; i <= end_group && (my_split > 0); i++) {
                            if (prev_start_group != nodes.get(i).getSplit_group()) {
                                prev_start_group = nodes.get(i).getSplit_group();
                                //old reasoning
                                //in case the random is in middle but we want the whole split
                                //i to be the first occurance of sub split inside the group
                                out_i = i;
                                my_split--;
                            }
                        }
                    }
                }

                if (start_with.equalsIgnoreCase("Literal")) {
                    // Make sure the Literal and LHS match..
                    String search_for = get_literal(scope_table.current_expression.getLhs_type());
//                    //System.out.println(" Encounter a literal.. search for " + scope_table.current_expression.getLhs_type() + " found " + search_for + " --");
                    for (int i = start_group; i <= end_group; i++) {
                        if (nodes.get(i).getName().contains(search_for)) {
                            out_i = i;
                            break;
                        }
                    }
                }

                // Update the child_node with newly updated valur of out_i
                child_node = nodes.get(out_i);

                // Checking if the node is terminal..!! Reduces work.
                if (child_node.isTerminal()) {
                    //System.out.println(" \n \t === " + child_node.getName() + " === \n");
                    if (child_node.getName().contains("Identifier")) {
                        // get the identifier to be created or used.
                        String identifier = identifier_rules(start_with,generated_code,child_node);
                        generated_code.append(identifier + " ");

                        // If its a function, we need to add the start braces as well..
                        if ( start_with.contains("ConstructorDeclaration")) {
                            generated_code.append("( " );
                        } else if ( start_with.contains("MethodDeclaration")) {
                            generated_code.append("( " );
                        } else if ( start_with.contains("MethodDefinition")) {
                            generated_code.append("( " );
                        }
                    } else {
                        // Just cases when not an identifier.. can be a keyword..!!!

                        // If we are specifying the return type.! make sure to record it in the method details
                        // to add a proper return statement at the end of the method.
                        if (start_with.contains("MReturnType")) {
                            scope_table.method_list.setCurrent_returntype(child_node.getName());
//                            //System.out.println(" ============the return type is " + child_node.getName());
                        } else if (start_with.contains("Type")) {
                            //if its of Type, record the type in the prev type for reference
                            //System.out.println("now @ type");
                            // add type to scope table, so we can update after creating identifier
                            scope_table.prev_type = child_node.getName();
                        } else if (start_with.contains("Integer") || start_with.contains(".") ||
                                start_with.contains("PrePostOperators") || start_with.contains("IncrementDecrement") ||
                                start_with.contains("Literal") || start_with.contains("Alphabet")) {
                            //remove unwanted indentation from before.
                            generated_code.replace(0,generated_code.length(),generated_code.toString().trim());
                        }
//                       //System.out.println(" now @ -- " + start_with + child_node.getName());
                        if(child_node.getName().contains("EndCond")) {
                            if(start_with.contains("ForStatement") ){
                                String temp = generated_code.substring(generated_code.lastIndexOf(";")+1,generated_code.length());
                                //System.out.println(" for string is " + temp + "--"+ temp.matches("\\s+"));
                                if(temp.matches("\\s+")) {
                                    //System.out.println("removing ; ");
                                    generated_code.delete(generated_code.lastIndexOf(";"),generated_code.length());
                                }
                            } else if (start_with.contains("MethodDefinition")) {
                                //System.out.println("adding to global interface...");
                                scope_table.global_interface_list.add(scope_table.interface_list);
                            }
                            generated_code.append(")");
                        } else if (child_node.getName().equalsIgnoreCase("CallMethodAgain")) {
                            generated_code.append(scope_table.method_list.getCurrent_method() + "()");
                        } else if (child_node.getName().equalsIgnoreCase("NameOfPackage")) {
                            generated_code.append(NameOfPackage + ";" + System.lineSeparator() );
                        } else if(start_with.contains("ForStatement") && child_node.getName().contains(";")){
                            String temp = generated_code.substring(generated_code.lastIndexOf(";")+1,generated_code.length());
                            //System.out.println(" for string is " + temp + "--"+ temp.matches("\\s+"));
                            if(temp.matches("\\s+")) {
                                //System.out.println("inserting ; ");
                                //System.out.println("toremoved" + generated_code.substring(generated_code.lastIndexOf(";")-13,generated_code.length()) + "----=-=-=-=-==");
                                generated_code.delete(generated_code.lastIndexOf(";"),generated_code.length());
                                //System.out.println("removed" + generated_code.substring(generated_code.lastIndexOf(";")+1,generated_code.length()) + "----=-=-=-=-==");
                            }
                            generated_code.append(child_node.getName());
                        } else {
                            generated_code.append(child_node.getName());
                        }
                        if( !child_node.getName().contains("'") && !child_node.getName().contains("\"") &&
                                !start_with.contains("IncrementDecrement") && !start_with.contains("PrePostOperators") ) {
                            // no space if was a quote
                            generated_code.append(" ");
                        }
                        // For these terminals wer need a start bracket.
                        if ( (( start_with.contains("IfThenStatement") || start_with.contains("Elseif") || start_with.contains("RecursiveTermination")) &&
                                child_node.getName().equalsIgnoreCase("if")) ||
                                child_node.getName().equalsIgnoreCase("while") ||
                                child_node.getName().equalsIgnoreCase("for")) {
                            generated_code.append("( ");
                        }
                        // new line if encountered a semicolon and add new line and further indentation.
                        if (child_node.getName().contains(";") && !start_with.contains("ForStatement")) {
                            generated_code.append(System.lineSeparator());
                            indent_generated_code(indentation, generated_code);
                            // check if we need to add one for if block and reset the others
                            // incase we don't want the recursive if being called right.
                            scope_table.current_expression.reset();
                            scope_table.current_expression.inc_method_line();
                        }
                    }
                } else {
                    // The various block structures where the { starts. Increase the indentation as well
                    if ( child_node.getName().contains("Body") ||
                            child_node.getName().contains("Block")) {
                        if (child_node.getName().contains("ConstructorBody")) {
                            generated_code.append(" ) ");
                        } else if (child_node.getName().contains("MethodBody") ||
                                child_node.getName().contains("RecursiveMBody") ) {
                            generated_code.append(" ) ");
                            scope_table.current_expression.setMethod_lines(0);
                            my_specs.setMax_stmts_methods(scope_table.current_expression.getMax_statement());
                        } else if (child_node.getName().contains("Block") &&
                                !start_with.equalsIgnoreCase("ElsePart") &&
                                start_with.equalsIgnoreCase("for")) {
                            generated_code.append(" ) ");
                            //don't reset if still in same block
                            if (!start_with.contains("IfThenStatement") && !start_with.contains("Elseif") &&
                                    !start_with.contains("ForStatement") && !start_with.contains("WhileStatement")) {
                                scope_table.current_expression.setStatement_nest_level(0);
                            }
                        }
                        generated_code.append(" { \n ");
                        indentation++;
                        indent_generated_code(indentation,generated_code);
                    }

                    // Start of the Expression nesting.! to keep track of a break limit.
                    // Not doing will result in expression of expression and stackoverflow :D
                    if (start_with.contains("Expression")) {
                        scope_table.current_expression.setIs_arithmetic(true);
                        scope_table.current_expression.inc_Arithmetic_express_nesting_level();
                    } else if (start_with.contains("Statement")) {
                        scope_table.current_expression.inc_statement_nest_level();
                    }

//                    //System.out.println(" the stuff is " + child_node.getName() + " llimit is \n" + scope_table.current_expression.getStatement_nest_level())
                    // *** Recursive call with new rule to parsed and code generated so far ***
                    generate_program(child_node.getName(), generated_code);

                    // After building the stuff from previous call, check if the block or body ends.
                    // do the closing, new line and indentation stuff.
                    if ( child_node.getName().contains("Body") ||
                            child_node.getName().contains("Block")) {
                        generated_code.append(System.lineSeparator());
                        indentation--;
                        indent_generated_code(indentation,generated_code);
                        generated_code.append("} " + System.lineSeparator());
                        indent_generated_code(indentation,generated_code);
                    }
                }

                // need to see if there is some left in the same split to continue within the group
                boolean more_in_split = false;
                for (int i = out_i+1; i <= end_group; i++) {
                    if (nodes.get(out_i).getSplit_group() == nodes.get(i).getSplit_group()) {
                        //in case the random is in middle but we want the whole split
                        //i to be the first occurance of sub split inside the group
                        more_in_split = true;
                        break;
                    }
                }

                //System.out.println(" more in split?? " + more_in_split + " for " + child_node.getName());
                if (!more_in_split ) {
                    // logic to check if constructor duplication doesn't happen
                    // incase it happens, we won't be able to edit the already made decision,
                    // so logically we add more to better off this one.
                    // see if its the parameter and there aren't more possibilities, increase count by 1
                    if (start_with.contains("CParameterList") && (occur_left-1) < 1 ) {
                        //System.out.println(" ...............checking duplication..");
                        //     //System.out.println(" \n\n\n*************" + start_with);
                        if (scope_table.constructor_list.is_duplication()) {
                            //System.out.println(" constructor .. " + scope_table.constructor_list.toString());
                            //System.out.println(" Found a duplication..!!");
                            occur_left++;
                        }
                    }
                    //System.out.println(" the occurrence left for " + child_node.getName());
                    if ((--occur_left > 0 )) {
                        //System.out.println(" the occurrence reduced for " + child_node.getName());
                        if(start_with.contains("CParameterList")) {
                            // shouldn't be changing strucutre of cparameterlist.
                            child_node = nodes.get(nodes.size()-1);
                        }

                        //need to find start of the group since we kept pushing it up.
                        for (int i = 0; i <= nodes.size(); i++) {
                            if (child_node.getGroup() == nodes.get(i).getGroup()) {
                                if (child_node.getSplit_group() == nodes.get(i).getSplit_group()) {
                                    out_i = i-1; //updated the value.
                                    break; //no need to continue
                                }
                            }
                        }
                    } else {
                        //if (!more_in_split) {
                        //System.out.println(" ended group..");
                        occur_left = 1;
                        check_chance = true;
                        out_i = end_group;
                    }
                }
            // end of for loop
            }
        } else {
            //System.out.println(" unable to start... bad rule.!!");
        }
        return generated_code.toString();
    }

    private void inc_restriction(String name, int occur_left) {
        switch (name) {
            case "FieldDeclarator":
                my_specs.decMax_class_field(occur_left);
                break;
            case "ConstructorDeclaration":
                my_specs.decgetMax_constructors(occur_left);
                break;
            case "MethodDeclaration":
                my_specs.decMax_methods_class(occur_left);
                break;
            case "RMethodDeclaration":
                my_specs.decRecur_probab(occur_left);
                break;
            case "InterfaceDeclaration":
                my_specs.decNumber_of_interfaces(occur_left);
                break;
            case "ClassDeclaration":
                my_specs.decNumber_of_classes(occur_left);
                break;
            case "MethodDefinition":
                my_specs.decMax_number_of_interfaces(occur_left);
                break;
            case "MParameter":
                my_specs.decgetMax_para_method(occur_left);
                break;
            case "WhileStatement":
                case "ForStatement":
            case "DoStatement":
                my_specs.decMaxloops(occur_left);
                break;
            case "IfThenStatement":
                my_specs.decMaxifstatement(occur_left);
                break;
            case "Statement":
                my_specs.decMax_stmts_methods(occur_left);
                break;
        }
    }

    private int check_restrictions(String name) {
        switch (name) {
            case "FieldDeclarator":
                if(my_specs.getMax_class_field() > 0) {
                    //System.out.println(" Field size is " + my_specs.getMax_class_field());
                    return my_specs.getMax_class_field();
                } else {
                    //System.out.println(" the current field size is " + my_specs.getMax_class_field());
                    return -1;
                }
            case "ConstructorDeclaration":
                if(my_specs.getMax_constructors() > 0) {
                    //System.out.println(" Field size is " + my_specs.getMax_constructors());
                    return my_specs.getMax_constructors();
                } else {
                    //System.out.println(" the current field size is " + my_specs.getMax_constructors());
                    return -1;
                }
            case "MethodDeclaration":
                if(my_specs.getMax_methods_class() > 0) {
                    //System.out.println(" Field size is " + my_specs.getMax_methods_class());
                    return my_specs.getMax_methods_class();
                } else {
                    //System.out.println(" the current field size is " + my_specs.getMax_methods_class());
                    return -1;
                }
            case "RMethodDeclaration":
                if(my_specs.getRecur_probab() > 0) {
                    //System.out.println(" Field size is " + my_specs.getRecur_probab());
                    return my_specs.getRecur_probab();
                } else {
                    //System.out.println(" the current field size is " + my_specs.getRecur_probab());
                    return -1;
                }
            case "InterfaceDeclaration":
                if(my_specs.getNumber_of_interfaces() > 0) {
                    //System.out.println(" Field size is " + my_specs.getNumber_of_interfaces());
                    return my_specs.getNumber_of_interfaces();
                } else {
                    //System.out.println(" the current field size is " + my_specs.getNumber_of_interfaces());
                    return -1;
                }
            case "ClassDeclaration":
                if(my_specs.getNumber_of_classes() > 0) {
                    //System.out.println(" Field size is " + my_specs.getNumber_of_classes());
                    return my_specs.getNumber_of_classes();
                } else {
                    //System.out.println(" the current field size is " + my_specs.getNumber_of_classes());
                    return -1;
                }
            case "MethodDefinition":
                if(my_specs.getMax_number_of_interfaces() > 0) {
                    //System.out.println(" Field size is " + my_specs.getMax_number_of_interfaces());
                    return my_specs.getMax_number_of_interfaces();
                } else {
                    //System.out.println(" the current field size is " + my_specs.getMax_number_of_interfaces());
                    return -1;
                }
            case "MParameter":
                if(my_specs.getMax_para_method() > 0) {
                    //System.out.println(" Field size is " + my_specs.getMax_para_method());
                    return my_specs.getMax_para_method();
                } else {
                    //System.out.println(" the current field size is " + my_specs.getMax_para_method());
                    return -1;
                }
            case "WhileStatement":
            case "ForStatement":
            case "DoStatement":
                if(my_specs.getMaxloops() > 0) {
                    //System.out.println(" Field size is " + my_specs.getMaxloops());
                    return my_specs.getMaxloops();
                } else {
                    //System.out.println(" the current field size is " + my_specs.getMaxloops());
                    return -1;
                }
            case "IfThenStatement":
                if(my_specs.getMaxifstatement() > 0) {
                    //System.out.println(" Field size is " + my_specs.getMax_stmts_methods());
                    return my_specs.getMax_stmts_methods();
                } else {
                    //System.out.println(" the current field size is " + my_specs.getMax_stmts_methods());
                    return -1;
                }
            case "Statement":
                if(my_specs.getMax_stmts_methods() > 0) {
                    //System.out.println(" Field size is " + my_specs.getMax_stmts_methods());
                    return my_specs.getMax_stmts_methods();
                } else {
                    //System.out.println(" the current field size is " + my_specs.getMax_stmts_methods());
                    return -1;
                }
        }
        return 2;
    }
    //relation expression add double and int check only
}
